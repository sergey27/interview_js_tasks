/*
    Реализуйте функцию memoize, которая принимает функцию fn и возвращает её мемоизированную версию.
    Мемоизированная функция никогда не должна вызывать fn дважды для одного и того же набора аргументов
    — она запоминает результат первого вызова и возвращает его из кеша для всех последующих.

    Два объекта с разной ссылкой, но одним и тем же набором полей и значений считаются одинаковыми.

    Формат ввода
    Вы должны экспортировать функцию memoize, которая в качестве аргумента принимает функцию fn.

    Функция fn в качестве аргументов может принимать примитивы (строки, числа, булевы значения), массивы и объекты.
    Значения, которые нельзя сериализовать через JSON.stringify (например, функции, undefined, Symbol, BigInt,
    циклические ссылки и т. п.), передаваться не будут.
    Два массива с одинаковыми элементами, расположенными в разном порядке, считаются разными.
    Например, [1, 2] и [2, 1] — это разные массивы.
    В тестах не будет случаев, когда объекты отличаются только порядком полей.
    Например, объекты {a: 1, b: 2} и {b: 2, a: 1} не будут встречаться в рамках одного и того же теста.
    Формат вывода
    Вывод тестирующей системы будет содержать блоки с информацией о каждом вызове memoizedFn:
    переданные аргументы, вернувшийся результат и флаг Invoked, который указывает, была ли вызвана исходная функция.
 */


function fn(a, b) {
    return a + b;
}

function memoize(fn) {
    const map = new Map();
    return function(...args){
        const key = JSON.stringify(args);
        if (map.has(key)){
            console.log("Invoked: false")
            return map.get(key);
        }

        const result = fn(...args);
        map.set(key, result);
        console.log("Invoked: true");
        return result;
    }
}

const memoizedFn = memoize(fn);
memoizedFn(1, 2);
memoizedFn(1, 2);


